# US-11.3 - Order Book Resilience & Recovery

**Epic:** Order Book & Market Depth  
**Phase:** Phase 11 - Order Book  
**Status:** Not Started  
**Priority:** Critical  
**Complexity:** Medium  

## User Story

As a **trader relying on order book data**,  
I want the order book to automatically detect and recover from connection issues, data gaps, and synchronization errors,  
so that I can trust the order book display is accurate and never trade on stale or incorrect data.

## Acceptance Criteria

### 1. Gap Detection via Sequence Numbers
- [ ] Every order book message (snapshot/delta) has a monotonic sequence number
- [ ] Client tracks last received sequence number
- [ ] Detect gaps: `receivedSeq != lastSeq + 1`
- [ ] Automatic gap detection triggers resync flow
- [ ] Log gap events for debugging

### 2. Automatic Resync on Gaps
- [ ] On gap detection, request missing deltas from server
- [ ] If deltas unavailable (too old), request full snapshot
- [ ] Apply missed deltas in order to reconstruct state
- [ ] Verify sequence continuity after resync
- [ ] Resume normal delta streaming after successful resync

### 3. WebSocket Reconnection Handling
- [ ] Detect WebSocket disconnection immediately
- [ ] Show "Disconnected" warning banner to user
- [ ] Automatic reconnection with exponential backoff
  - 1st retry: 1 second
  - 2nd retry: 2 seconds
  - 3rd retry: 4 seconds
  - Max: 30 seconds
- [ ] On reconnect, request full snapshot (state may have changed)
- [ ] Clear "Disconnected" warning after successful reconnect

### 4. Out-of-Sync Detection & Warning
- [ ] Display "Out of Sync" warning when:
  - Sequence gap detected and resync in progress
  - WebSocket disconnected
  - No updates received in >10 seconds (stale data)
- [ ] Visual indicator: Red banner, grayed-out order book
- [ ] Prevent order placement while out of sync
- [ ] Manual "Force Resync" button for user-initiated recovery

### 5. Heartbeat & Staleness Detection
- [ ] Server sends heartbeat message every 5 seconds if no updates
- [ ] Client tracks time since last message
- [ ] Show warning if no message received in >10 seconds
- [ ] Auto-reconnect if no heartbeat for >30 seconds

### 6. Delta Replay Buffer (Server-Side)
- [ ] Server maintains buffer of last N deltas per instrument (e.g., 1000)
- [ ] Client can request deltas from sequence X to Y
- [ ] If requested deltas expired, return full snapshot instead
- [ ] Buffer size configurable per instrument liquidity

## Technical Requirements

### Backend

#### Enhanced Models
```go
// Heartbeat message
type OrderBookHeartbeat struct {
    Type      string    `json:"type"` // "HEARTBEAT"
    Sequence  int64     `json:"sequence"`
    Timestamp time.Time `json:"timestamp"`
}

// Resync request
type ResyncRequest struct {
    InstrumentID string `json:"instrument_id"`
    FromSequence int64  `json:"from_sequence"`
}

// Resync response
type ResyncResponse struct {
    Type     string              `json:"type"` // "RESYNC"
    Deltas   []OrderBookDelta    `json:"deltas,omitempty"`
    Snapshot *OrderBook          `json:"snapshot,omitempty"`
}
```

#### Service Enhancements: `OrderBookService`
- **Method**: `GetDeltasSince(instrumentID string, fromSeq int64) ([]OrderBookDelta, error)`
  - Return buffered deltas from sequence X onwards
  - Return nil if deltas expired (too old)
  
- **Method**: `SendHeartbeat(instrumentID string)`
  - Broadcast heartbeat to all subscribers
  - Include current sequence number
  
- **Method**: `HandleResyncRequest(req ResyncRequest) (*ResyncResponse, error)`
  - Attempt to return deltas
  - Fall back to snapshot if deltas unavailable

#### Delta Buffer Implementation
```go
type DeltaBuffer struct {
    instrumentID string
    deltas       []OrderBookDelta
    maxSize      int
    mu           sync.RWMutex
}

func (b *DeltaBuffer) Add(delta OrderBookDelta) {
    b.mu.Lock()
    defer b.mu.Unlock()
    b.deltas = append(b.deltas, delta)
    if len(b.deltas) > b.maxSize {
        b.deltas = b.deltas[1:] // Remove oldest
    }
}

func (b *DeltaBuffer) GetSince(seq int64) ([]OrderBookDelta, bool) {
    b.mu.RLock()
    defer b.mu.RUnlock()
    // Find deltas with sequence >= seq
    // Return (deltas, true) if found, (nil, false) if too old
}
```

#### WebSocket Protocol Extensions
- **Client → Server**: `{ "type": "RESYNC", "from_sequence": 12345 }`
- **Server → Client**: Resync response (deltas or snapshot)
- **Server → Client**: Heartbeat every 5 seconds

### Frontend

#### Enhanced Components
- **`OrderBookSyncStatus.tsx`**: Sync status indicator
  - Green: "Live"
  - Yellow: "Reconnecting..."
  - Red: "Out of Sync"
  - Display last update timestamp
  
- **`ResyncButton.tsx`**: Manual resync trigger
  - Visible when out of sync
  - Request full snapshot on click

#### Enhanced Hooks: `useOrderBook.ts`
```typescript
interface OrderBookState {
  book: OrderBook | null;
  lastSequence: number;
  isConnected: boolean;
  isSynced: boolean;
  lastUpdateTime: Date | null;
  error: string | null;
}

function useOrderBook(instrumentId: string) {
  const [state, setState] = useState<OrderBookState>({
    book: null,
    lastSequence: 0,
    isConnected: false,
    isSynced: false,
    lastUpdateTime: null,
    error: null,
  });

  // Gap detection
  const handleMessage = (msg: OrderBookMessage) => {
    if (msg.type === 'DELTA') {
      const delta = msg.data as OrderBookDelta;
      if (delta.sequence !== state.lastSequence + 1) {
        // Gap detected!
        requestResync(state.lastSequence + 1);
        setState({ ...state, isSynced: false, error: 'Gap detected' });
        return;
      }
      // Apply delta
      applyDelta(delta);
      setState({ ...state, lastSequence: delta.sequence, lastUpdateTime: new Date() });
    }
  };

  // Staleness detection
  useEffect(() => {
    const interval = setInterval(() => {
      if (state.lastUpdateTime && Date.now() - state.lastUpdateTime.getTime() > 10000) {
        setState({ ...state, isSynced: false, error: 'Stale data' });
      }
    }, 1000);
    return () => clearInterval(interval);
  }, [state.lastUpdateTime]);

  return { ...state, forceResync };
}
```

#### Reconnection Logic
```typescript
function useWebSocketReconnect(url: string) {
  const [retryCount, setRetryCount] = useState(0);
  
  const connect = () => {
    const ws = new WebSocket(url);
    
    ws.onclose = () => {
      const delay = Math.min(1000 * Math.pow(2, retryCount), 30000);
      setTimeout(() => {
        setRetryCount(retryCount + 1);
        connect();
      }, delay);
    };
    
    ws.onopen = () => {
      setRetryCount(0);
      // Request snapshot on reconnect
      ws.send(JSON.stringify({ type: 'SNAPSHOT_REQUEST' }));
    };
  };
  
  return connect;
}
```

## Dependencies

- US-11.1: Real-time Order Book (base functionality)
- US-6.1: Matching Engine (order book updates)

## Implementation Notes

### Sequence Number Generation
- Use atomic counter per instrument
- Increment on every order book change
- Never reuse sequence numbers
- Persist last sequence to DB for recovery

### Buffer Size Tuning
- High liquidity instruments: 1000 deltas (~1-2 minutes)
- Medium liquidity: 500 deltas
- Low liquidity: 100 deltas
- Configurable via system config

### Heartbeat Frequency
- Default: 5 seconds
- Adjustable based on instrument activity
- Include sequence number to detect gaps even during quiet periods

### Edge Cases
- **Rapid Reconnects**: Prevent reconnect spam with exponential backoff
- **Concurrent Gaps**: Queue resync requests, process sequentially
- **Snapshot During Resync**: Cancel in-flight resync if snapshot received
- **Buffer Overflow**: Oldest deltas expire, client must request snapshot

## Testing Requirements

### Unit Tests
- [ ] Test gap detection logic
- [ ] Test delta buffer add/retrieve
- [ ] Test sequence number continuity
- [ ] Test reconnection backoff calculation

### Integration Tests
- [ ] Test resync request/response flow
- [ ] Test heartbeat mechanism
- [ ] Test delta replay from buffer
- [ ] Test snapshot fallback when deltas unavailable

### E2E Scenarios
- [ ] Simulate WebSocket disconnect and reconnect
- [ ] Simulate packet loss (missing delta)
- [ ] Verify gap detection and automatic resync
- [ ] Verify "Out of Sync" warning displays correctly
- [ ] Verify manual force resync works

### Chaos Testing
- [ ] Random WebSocket disconnections
- [ ] Random message drops
- [ ] Network latency spikes
- [ ] Verify order book always recovers to correct state

## Audit Trail

| Date | Author | Change |
|------|--------|--------|
| 2026-01-18 | AI Assistant | Initial creation of US-11.3 based on resilience requirements |
